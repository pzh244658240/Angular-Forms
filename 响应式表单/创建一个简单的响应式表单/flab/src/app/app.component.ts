import {Component} from '@angular/core';

/**
 * 响应式表单
 * 响应式表单是 Angular 中用响应式风格创建表单的技术。
 *
 * 响应式表单简介
 * Angular 提供了两种构建表单的技术：响应式表单和模板驱动表单。
 * 这两项技术都属于 @angular/forms 库，并且共享一组公共的表单控件类。
 *
 * 但是它们在设计哲学、编程风格和具体技术上有显著区别。
 * 所以，它们都有自己的模块：ReactiveFormsModule 和 FormsModule。
 *
 * 响应式表单
 * Angular 的响应式表单能让实现响应式编程风格更容易，
 * 这种编程风格更倾向于在非 UI 的数据模型（通常接收自服务器）之间显式的管理数据流，
 * 并且用一个 UI 导向的表单模型来保存屏幕上 HTML 控件的状态和值。
 * 响应式表单可以让使用响应式编程模式、测试和校验变得更容易。
 *
 * 使用响应式表单，你可以在组件中创建表单控件的对象树，
 * 并使用本章中传授的技巧把它们绑定到组件模板中的原生表单控件元素上。
 *
 * 你可以在组件类中直接创建和维护表单控件对象。
 * 由于组件类可以同时访问数据模型和表单控件结构，
 * 因此你可以把表单模型值的变化推送到表单控件中，并把变化后的值拉取回来。
 * 组件可以监听表单控件状态的变化，并对此做出响应。
 *
 * 直接使用表单控件对象的优点之一是值和有效性状态的更新总是同步的，并且在你的控制之下。
 * 你不会遇到时序问题，这个问题有时在模板驱动表单中会成为灾难。而且响应式表单更容易进行单元测试。
 *
 * 在响应式编程范式中，组件会负责维护数据模型的不可变性，把模型当做纯粹的原始数据源。
 * 组件不会直接更新数据模型，而是把用户的修改提取出来，把它们转发给外部的组件或服务，
 * 外部程序才会使用这些进行处理（比如保存它们）， 并且给组件返回一个新的数据模型，以反映模型状态的变化。
 *
 * 使用响应式表单的指令，并不要求你遵循所有的响应式编程原则，但它能让你更容易使用响应式编程方法，从而更愿意使用它。
 *
 * 模板驱动表单
 * 在模板一章中介绍过的模板驱动表单，是一种完全不同的方式。
 * 你把 HTML 表单控件（比如 <input> 和 <select>）放进组件模板中，
 * 并用 ngModel 等指令把它们绑定到组件中数据模型的属性上。
 *
 * 你不用自己创建 Angular 表单控件对象。
 * Angular 指令会使用数据绑定中的信息创建它们。
 * 你不用自己推送和拉取数据。
 * Angular 使用 ngModel 来替你管理它们。
 * 当用户做出修改时，Angular 会据此更新可变的数据模型。
 *
 * 因此，ngModel 并不是 ReactiveFormsModule 模块的一部分。
 * 虽然这意味着组件中的代码更少，
 * 但是模板驱动表单是异步工作的，
 * 这可能在更高级的场景中让开发复杂化。
 *
 * 异步 vs. 同步
 * 响应式表单是同步的而模板驱动表单是异步的。
 *
 * 使用响应式表单，你会在代码中创建整个表单控件树。
 * 你可以立即更新一个值或者深入到表单中的任意节点，因为所有的控件都始终是可用的。
 *
 * 模板驱动表单会委托指令来创建它们的表单控件。
 * 为了消除“检查完后又变化了”的错误，这些指令需要消耗一个以上的变更检测周期来构建整个控件树。
 * 这意味着在从组件类中操纵任何控件之前，你都必须先等待一个节拍。
 *
 * 比如，如果你用 @ViewChild(NgForm) 查询来注入表单控件，
 * 并在生命周期钩子 ngAfterViewInit中检查它，就会发现它没有子控件。
 * 你必须使用 setTimeout 等待一个节拍才能从控件中提取值、测试有效性，或把它设置为新值。
 *
 * 模板驱动表单的异步性让单元测试也变得复杂化了。
 * 你必须把测试代码包裹在 async() 或 fakeAsync() 中来解决要查阅的值尚不存在的情况。
 * 使用响应式表单，在所期望的时机一切都是可用的。
 *
 * 选择响应式表单还是模板驱动表单？
 * 响应式表单和模板驱动表单是两种架构范式，各有优缺点。 请自行选择更合适的方法，甚至可以在同一个应用中同时使用它们。
 *
 * FormControl 是一个指令，它允许你直接创建并管理一个 FormControl 实例。
 */
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
}
