import {Component} from '@angular/core';

/**
 * 响应式表单
 * 响应式表单是 Angular 中用响应式风格创建表单的技术。
 *
 * 响应式表单简介
 * Angular 提供了两种构建表单的技术：响应式表单和模板驱动表单。
 * 这两项技术都属于 @angular/forms 库，并且共享一组公共的表单控件类。
 *
 * 但是它们在设计哲学、编程风格和具体技术上有显著区别。
 * 所以，它们都有自己的模块：ReactiveFormsModule 和 FormsModule。
 *
 * 响应式表单
 * Angular 的响应式表单能让实现响应式编程风格更容易，
 * 这种编程风格更倾向于在非 UI 的数据模型（通常接收自服务器）之间显式的管理数据流，
 * 并且用一个 UI 导向的表单模型来保存屏幕上 HTML 控件的状态和值。
 * 响应式表单可以让使用响应式编程模式、测试和校验变得更容易。
 *
 * 使用响应式表单，你可以在组件中创建表单控件的对象树，
 * 并使用本章中传授的技巧把它们绑定到组件模板中的原生表单控件元素上。
 *
 * 你可以在组件类中直接创建和维护表单控件对象。
 * 由于组件类可以同时访问数据模型和表单控件结构，
 * 因此你可以把表单模型值的变化推送到表单控件中，并把变化后的值拉取回来。
 * 组件可以监听表单控件状态的变化，并对此做出响应。
 *
 * 直接使用表单控件对象的优点之一是值和有效性状态的更新总是同步的，并且在你的控制之下。
 * 你不会遇到时序问题，这个问题有时在模板驱动表单中会成为灾难。而且响应式表单更容易进行单元测试。
 *
 * 在响应式编程范式中，组件会负责维护数据模型的不可变性，把模型当做纯粹的原始数据源。
 * 组件不会直接更新数据模型，而是把用户的修改提取出来，把它们转发给外部的组件或服务，
 * 外部程序才会使用这些进行处理（比如保存它们）， 并且给组件返回一个新的数据模型，以反映模型状态的变化。
 *
 * 使用响应式表单的指令，并不要求你遵循所有的响应式编程原则，但它能让你更容易使用响应式编程方法，从而更愿意使用它。
 *
 * 模板驱动表单
 * 在模板一章中介绍过的模板驱动表单，是一种完全不同的方式。
 * 你把 HTML 表单控件（比如 <input> 和 <select>）放进组件模板中，
 * 并用 ngModel 等指令把它们绑定到组件中数据模型的属性上。
 *
 * 你不用自己创建 Angular 表单控件对象。
 * Angular 指令会使用数据绑定中的信息创建它们。
 * 你不用自己推送和拉取数据。
 * Angular 使用 ngModel 来替你管理它们。
 * 当用户做出修改时，Angular 会据此更新可变的数据模型。
 *
 * 因此，ngModel 并不是 ReactiveFormsModule 模块的一部分。
 * 虽然这意味着组件中的代码更少，
 * 但是模板驱动表单是异步工作的，
 * 这可能在更高级的场景中让开发复杂化。
 *
 * 异步 vs. 同步
 * 响应式表单是同步的而模板驱动表单是异步的。
 *
 * 使用响应式表单，你会在代码中创建整个表单控件树。
 * 你可以立即更新一个值或者深入到表单中的任意节点，因为所有的控件都始终是可用的。
 *
 * 模板驱动表单会委托指令来创建它们的表单控件。
 * 为了消除“检查完后又变化了”的错误，这些指令需要消耗一个以上的变更检测周期来构建整个控件树。
 * 这意味着在从组件类中操纵任何控件之前，你都必须先等待一个节拍。
 *
 * 比如，如果你用 @ViewChild(NgForm) 查询来注入表单控件，
 * 并在生命周期钩子 ngAfterViewInit中检查它，就会发现它没有子控件。
 * 你必须使用 setTimeout 等待一个节拍才能从控件中提取值、测试有效性，或把它设置为新值。
 *
 * 模板驱动表单的异步性让单元测试也变得复杂化了。
 * 你必须把测试代码包裹在 async() 或 fakeAsync() 中来解决要查阅的值尚不存在的情况。
 * 使用响应式表单，在所期望的时机一切都是可用的。
 *
 * 选择响应式表单还是模板驱动表单？
 * 响应式表单和模板驱动表单是两种架构范式，各有优缺点。 请自行选择更合适的方法，甚至可以在同一个应用中同时使用它们。
 *
 * FormControl 是一个指令，它允许你直接创建并管理一个 FormControl 实例。
 *
 * 基础的表单类
 * AbstractControl
 * AbstractControl是这三个具体表单类的抽象基类。 并为它们提供了一些共同的行为和属性。
 *
 * FormControl
 * FormControl 用于跟踪一个单独的表单控件的值和有效性状态。
 * 它对应于一个 HTML 表单控件，比如 <input> 或 <select>。
 *
 * FormGroup
 * FormGroup用于 跟踪一组AbstractControl 的实例的值和有效性状态。
 * 该组的属性中包含了它的子控件。
 * 组件中的顶级表单就是一个 FormGroup。
 *
 * FormArray
 * FormArray用于跟踪 AbstractControl 实例组成的有序数组的值和有效性状态。
 *
 * 为应用添加样式
 * 要在 AppComponent 和 HeroDetailComponent 的模板中使用 Bootstrap 中的 CSS 类。
 * 请把 bootstrap 的CSS 样式表文件添加到 style.css 的头部：
 * @import url('https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css');
 *
 * 添加 FormGroup
 * 通常，如果有多个 FormControl，你要把它们都注册进一个父 FormGroup 中。
 *
 * 表单模型概览
 * 当用户在 <input> 中输入数据时，它的值就会进入这个表单模型。
 * 要想知道表单模型是什么样的，请在 hero-detail.component.html 的 <form> 标签紧后面添加如下代码：
 * <p>Form value: {{ heroForm.value | json }}</p>
 * heroForm.value 会返回表单模型。 用 JsonPipe 管道把这个模型以 JSON 格式渲染到浏览器中。
 * 最初的 name 属性是个空字符串，在 name <input> 中输入之后，可以看到这些按键出现在了 JSON 中。
 * 在真实的应用中，表单很快就会变大。 FormBuilder 能让表单开发和维护变得更简单。
 */
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
}
